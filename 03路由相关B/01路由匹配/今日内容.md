## 1. 路由匹配  
### 1.如何应用好 slash  
> 我们经常会写 *'index/'*,就跟flask的一样,但是这个到底是什么意思??可能已经忘了  
> 这里就当是回顾,flask,django,fastapi这些框架对于这一点都是一致的   

看下面这个例子
```python
    path('login/',views.login) 
    #如果我们访问的是0.0.0.0/login/是可正常访问的

    #如果不加上也是可以显示的,但是会进行重定向(301)
    #0.0.0.0/login 会自动加上最后的 / 这样相当于进行了自动匹配

        
   ```
- 所以推荐的写法是加上斜杠,这样既可以支持带斜杠的也可以匹配不带斜杠的进行重定向

当然,如果定义的时候是这样的 
```python
    path('login',views.login)
   #那这样就只能通过严格的0.0.0.0/login来访问了,加上最后的斜杠是会报错的

```

- 小结:可以将带/理解为不严格自动匹配路由,不带斜杠的是严格匹配路由
2. 为什么可以自动匹配自动重定向加上/的呢?
因为django有一个配置文件,其中写了一个APPEND_SLASH =True，也就是自动加上/ 
如果自己想加的话就在主路由的`settings.py`中加上 **`APPEND_SLASH=TRUE`**


## 2.当前匹配对象(解析匹配)
引言:
  之前学习flask的时候可以在终端输出flask routes来查看当前匹配路由   
  或者是打印输出 app.url_map 来查看路由映射 
  亦或是debug模式下自动打印路由  
在Django中也有这样的功能,它就是 **解析匹配**request.resolver(解析器)_match(匹配)
### 2.1  像flask的 app.url_map 一样输出当前的路由  
> 在django中,有一个像flask的app.url_map那样可以输出当前匹配路由的功能   
> Django中的这个叫做 **`request.resolver_match`** 

### 2.2 它的作用是什么??
> 某用户,具有一些权限  permission = ['xx','login','account']
> 某用户,具有一些权限 permission =[ 'login','account' ]
- 例子 
```python
def login(request):
    #1.获取当前用户的所有权限 
    permissions = ['xx','login','account']
    
    #2.判断是否有权限  
    current_name = request.resolver_match.url_name  
    if current_name not in permissions:  
         return HTTPResponse('当前用户无权限')
    else:
        return HTTPResponse('权限验证成功')
```

之后这个玩意儿将会大有用处,现在只是打个照面

- 补充知识点 ，关于Partial()
它是python内部提供的一个功能
```python
from functools import partial

def _xx(a1,a2):
    return a1+a2 

#可以调用partial(func)对函数进行改造然后返回一个新的函数
newfunc = partial(_xx)

raw = newfunc(1,1)
#这样执行的其实还是_xx(1,1) = 2 

#其实还可以这样使用 
newfunc1  = partial(_xx,a2=200)

#这时候这样执行
raw2 = newfunc1(1) #这样相当于_xx(1,200),这样就算指定一个也是可以将默认值a2=200带进去的


```