## 路由分发  

### 路由的手动分发  

路由的手动分发可以与`app`无关   

- 之前我们写的都是这样的,主路由中include apps中的路由

```python   
    from django.contrib import admin
    from django.urls import path,include
    
    urlpatterns = [
        path('admin/', admin.site.urls),
        path('web/',include("apps.web.urls"))
    ]
    
   ```  

- 但其实也可以手动分发路由  
  - 使用场景:没有多个app,但是单个app中有许多功能的时候
  - ```python  
    
     #当app的数量不多的时候,我们只需要在主路由的urls.py中进行路由的编写
    from django.urls import path
    #例如我们有一个apps.api
    
    from apps.api import view #就像之前那样导入
    
    urlpatterns=[
        path('auth/',views.auth),
        path('login/',views.login),
    
        path('user/add/',views.add),
        path('user/delete/',views.delete),
        path('user/edit/',views.login),
        path('user/list/',views.login)
    
        #像上面模拟的类似于crud的数据库操作的路由前缀都是一样的,可是这样写实在很累很麻烦
        #那我们就可以像下面这样直接写一个元祖,这样共同前缀就不用编写了
        path('user/',([
            path('add/',views.add),
            path('delete/',views.delete),
            path('edit/',views.edit),
            path('list/',views.list)
                        ],None,None))
    ]
    ```  
    
### include的本质
学完上面的手动分发之后应该能了解到之前学的include和手动分发其实非常像 
- url对应函数  
```python
path('user/add/',views.login)
```
- url对应元祖  
```python
path('user/',([
            path('add/',views.add),
            path('delete/',views.delete),
            path('edit/',views.edit),
            path('list/',views.list)
                        ],None,None))
```
- 除了放元祖外还可以放之前学的include函数  
```python
path('user/',include("apps.web.urls"))
```
- 来重点看一下include的源代码 
```python3
from importlib import import_module   #这个包可以从类似于"apps.web.urls"中解析到要导入的包 相当于import_module("apps.web.urls")跟 from apps.web import urls是一样的
def include(arg, namespace=None):
    app_name = None
    if isinstance(arg, tuple):   #先来判断传入的参数是不是一个元组
        # Callable returning a namespace hint.
        try:
            urlconf_module, app_name = arg
        except ValueError:
            if namespace:
                raise ImproperlyConfigured(
                    'Cannot override the namespace for a dynamic module that '
                    'provides a namespace.'
                )
            raise ImproperlyConfigured(
                'Passing a %d-tuple to include() is not supported. Pass a '
                '2-tuple containing the list of patterns and app_name, and '
                'provide the namespace argument to include() instead.' % len(arg)
            )
    else:
        # No namespace hint - use manually provided namespace.
        urlconf_module = arg

    if isinstance(urlconf_module, str):
        urlconf_module = import_module(urlconf_module)
    
    patterns = getattr(urlconf_module, 'urlpatterns', urlconf_module)
    #例如传入的args是"apps.web.urls" 那么就会去这个urls.py里找urlpatterns
    app_name = getattr(urlconf_module, 'app_name', app_name)
    if namespace and not app_name:
        raise ImproperlyConfigured(
            'Specifying a namespace in include() without providing an app_name '
            'is not supported. Set the app_name attribute in the included '
            'module, or pass a 2-tuple containing the list of patterns and '
            'app_name instead.',
        )
    namespace = namespace or app_name
    # Make sure the patterns can be iterated through (without this, some
    # testcases will break).
    if isinstance(patterns, (list, tuple)): #这里就是手动分发路由的时候用到的传入的patterns列表
        for url_pattern in patterns: #循环拿出路由
            pattern = getattr(url_pattern, 'pattern', None)
            if isinstance(pattern, LocalePrefixPattern): #如果是可以定位的带前缀的路由
                raise ImproperlyConfigured(
                    'Using i18n_patterns in an included URLconf is not allowed.'
                )
    return (urlconf_module, app_name, namespace)  
    
    #这里可以看到include的返回值是一个元祖,第一个是对应的url配置的模型,第二个是app的名称,第三个是域名

```


### 补充的反射机制  
- 上面聊到 from importlib import import_module,其实还可以利用其反射机制来反向操作
```python
from importlib import import_module
path = "apps.web.urls"
md = import_module(path)

#利用反射机制来拿到其中的元素  
v1 = getattr(md,"url_parttens") #相当于md.url_parttens


```


### 小结  
- include或手动分发，本质是相同的  
- 应用场景,想要吧一些url前缀提取出来
- 当然也可以用include传入一个元组  
- 可以看下面两种方式，实现的效果其实是一样的
```python
urlpatterns=[
        path('user/',([
            path('add/',views.add),
            path('delete/',views.delete),
            path('edit/',views.edit),
            path('list/',views.list)
                        ],None,None))
    ]




urlpatterns=[
        
        path('user/',include(([
            path('add/',views.add),
            path('delete/',views.delete),
            path('edit/',views.edit),
            path('list/',views.list)
        ],None)))
             ]
```


### 路由 - name (其实可以理解成flask中给路由指定endpoint,但是和endpoint作为url名称的效果不同)

- 其实就是给路由起一个名字,譬如路由是users_center/ 那么这个`center`就是user_center/的对应名而已
- 有了名字后有两处会用到   
- 用处1
  ```python
    """譬如有一个很长的路由 login/a/b/c/d/e 那么我们在重定向的时候就需要redirct('login/a/b/c/d/e')
    如果我们在urls中指定name之后，我们就可以利用reverse来进行反向调用,这对于进行重定向非常方便,譬如我们在进行用户的操作前需要先进行授权登录"""
  # 在urls.py中这样写
  from apps.web import views
  from django.contrib import admin
  from django.urls import path, include
  
  urlpatterns = [
      path('user/', ([
                         path('add/', views.add,name='useradd'),
                         path('auth/',views.auth,name='auth'),
                         path('delete/', views.delete),
                     ], None, None))
  ]
  #然后在views中这么写
  from django.shortcuts import render, redirect

  # Create your views here.
  
  from django.http import HttpResponse
  from django.urls import reverse  #必须要导入这个包,然后才能利用reverse进行反向生成
  def home(request):
      return HttpResponse("主页")
  
  
  def auth(request):
      return HttpResponse('先进行授权')
  
  def add(request):
  
      url = reverse('auth') #这样可以根据name反向生成url
      return redirect(url)
      # return HttpResponse("用户添加操作")
  
  def delete(request):
      return HttpResponse('用户删除操作')
  ```
- 这样定义的话我们就不需要专门将add中重定向的url写成redirect('/web/auth'),而是简单的写成redirect(reverse('auth')), 
这样一来我们就只需要将注意力放在功能的区分命名上而不是记忆路由上


- 用处2 
- 之前学习flask的时候在某些a标签中可以指定url_for("user.login")这种方式来进行直接读取view中的路由,  
那么在django中可以使用类似的方式，同时应当注意url_for()是只有flask才有的,django中替代的方式就是现在学到的路由反向解析
```html
<a href="{% url 'login' %}}">登陆</a>
```

- 扩展，如果以后要做权限管理,那么可以在进行管理的时候用name,这样更隐蔽，而不是直接来一个admin
```python 
    urlpatterns=[
       path('admin',views.admin name='v1')
   ] 
```


### 实际案例  
- apps/web/views.py
```python
from django.shortcuts import render, redirect

# Create your views here.

from django.http import HttpResponse, request
from django.urls import reverse


def home(request):
    return HttpResponse("主页")


def login(request):
    #tips:先判断是什么请求
    if request.method == 'POST':
        username = request.POST.get('username')
        password = request.POST.get('password')
        print(username, password)
        return redirect(reverse('home'))
    return render(request, 'login.html')

```
注意记得在settings中导入

- 主urls.py
```python
from apps.web import views
from django.contrib import admin
from django.urls import path, include

urlpatterns = [
    path('user/', ([
                       path('home/',views.home,name='home'),
                       path('login/', views.login, name='login'),
                       path('add/', views.add, name='useradd'),
                       path('auth/', views.auth, name='auth'),
                       path('delete/', views.delete),
                   ], None, None))
]

```
-  apps/web/templates/login.html
```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>登陆</title>
</head>
<body>
<form id="loginForm" action="{% url 'login' %} " method="post">
    {% csrf_token %}
    <p><input placeholder="输入用户名" name="username" type="text"></p>
    <p><input placeholder="输入密码" name="password" type="text"></p>
    <button type="button" onclick="document.getElementById('loginForm').submit()">登录</button>
</form>
</body>
</html>
```