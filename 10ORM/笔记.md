## ORM(对象模型映射)

> 和之前在flask学习orm的性质和本质其实是差不多的,
> 也要学习关于一对一,一对多,多对多的关系,只是flask中的语法和django中的语法略有不同   

![img_1.png](img_1.png)

### orm创建表  
> 这里不妨回忆一下flask，自己之前要使用mtv模型的时候是这么做的   
> ![img_2.png](img_2.png)
> 
> 然后在exts里头这样定义
> ![img_3.png](img_3.png)
```python
"""
@File    :extensions.py
@Editor  : 百年
@Date    :2025/8/10 8:56 
"""
from flask_migrate import Migrate
from flask_sqlalchemy import SQLAlchemy

db = SQLAlchemy()
migrate = Migrate()
```

之后在app的model.py中这样写  
```python
from exts.extensions import db
from datetime import datetime


class User(db.Model):
    __tablename__ = 'user'
    id = db.Column(db.Integer, primary_key=True, autoincrement=True)
    username = db.Column(db.String(20), nullable=False)
    password = db.Column(db.String(128), nullable=False)  # 要放的是要加密的密码,所以大小应当是加密之后的大小,故db.String(Size) 的Size要谨慎设置
    phone = db.Column(db.String(11), unique=True, nullable=False)
    email = db.Column(db.String(30))
    icon = db.Column(db.String(100))
    regi_date = db.Column(db.DateTime, default=datetime.now)
    isdelete = db.Column(db.Boolean, default=False)  # 逻辑删除
    # start_cb:增减一个字段,不会在数据库中出现,用于链接字段,relationship是在view和templates中体现的
    articles = db.relationship('Article', backref='user', lazy='select')
    photo = db.relationship('Photo', backref='user')
    comment=db.relationship('Comment',backref='user')
    selfintro = db.Relationship('Aboutme',backref='user')
    # end_cb 需要注意它是模板层面的,所以不需要再做迁移操作
    def __str__(self):
        return self.username
```

但是Django直接继承了orm  

我们只需要在app的models.py中按照规则进行编写就可以了   

类似于这样  
```python
from django.db import models
class User(models.Model):
    name = models.CharField(max_length=16)
    age = models.IntegerField()

``` 


django中我们不用自己去声明主键,相对来说省了一点力气   

但是需要知道的是这只是完成了第一步,注意要将app在settings中注册  

接下来就像我们之前学的flask db cli那种操作一样对其进行初始生成表  

- `python manage.py makemigrations`(之前flask的是flask db init然后flask db migrate)
```commandline
(ISV) D:\haohaicheng\Djangolearn\10ORM>python manage.py makemigrations
Migrations for 'articles':
  apps\articles\migrations\0001_initial.py
    - Create model Articles
Migrations for 'user':
  apps\user\migrations\0001_initial.py
    - Create model User
```

- 这之后就像我们之前用flask一样,可以通过migrate的文件来查看创建表的结构    
如apps/user/migrations/0001_initial.py  
```python
# Generated by Django 3.2 on 2025-11-04 06:49

from django.db import migrations, models


class Migration(migrations.Migration):

    initial = True

    dependencies = [
    ]

    operations = [
        migrations.CreateModel(
            name='User',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.CharField(max_length=16)),
                ('age', models.IntegerField()),
            ],
        ),
    ]

```

如果觉得表不够还要接着创建表,创建完成之后就再次执行`python manage.py makemigration  `
```commandline
(ISV) D:\haohaicheng\Djangolearn\10ORM>python manage.py makemigrations
Migrations for 'user':
  apps\user\migrations\0002_departement.py
    - Create model Departement

```
就像我们之前flask那样,修改后进行flask db migrate然后进行`flask db upgrade`  这样的操作   


- 下一步我们就得通过命令将配置文件转换成相应的sql语句然后将其变成真正的表,  
- 需要将这些像flask upgrade那样   
但是语法是不同的,Django这里是进行`python manage.py migrate` 这样就可以将数据库创建好了  


### 需要注意的一点是,我们应该为其指定数据库,其实在settings.py中就可以修改   
```python
# Database
# https://docs.djangoproject.com/en/3.2/ref/settings/#databases

DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': BASE_DIR / 'db.sqlite3',
    }
}

```

之后如果不想用sqlite可以在这里着手更改   

接下来准备好之后运行`python manage.py migrate` 
它会去读取app下的migrations然后进行表的生成操作 
```commandline
(ISV) D:\haohaicheng\Djangolearn\10ORM>python manage.py migrate  
Operations to perform:
  Apply all migrations: admin, articles, auth, contenttypes, sessions, user
Running migrations:
  Applying contenttypes.0001_initial... OK
  Applying auth.0001_initial... OK
  Applying admin.0001_initial... OK
  Applying admin.0002_logentry_remove_auto_add... OK
  Applying admin.0003_logentry_add_action_flag_choices... OK
  Applying articles.0001_initial... OK
  Applying contenttypes.0002_remove_content_type_name... OK
  Applying auth.0002_alter_permission_name_max_length... OK
  Applying auth.0003_alter_user_email_max_length... OK
  Applying auth.0004_alter_user_username_opts... OK
  Applying auth.0005_alter_user_last_login_null... OK
  Applying auth.0006_require_contenttypes_0002... OK
  Applying auth.0007_alter_validators_add_error_messages... OK
  Applying auth.0008_alter_user_username_max_length... OK
  Applying auth.0009_alter_user_last_name_max_length... OK
  Applying auth.0010_alter_group_name_max_length... OK
  Applying auth.0011_update_proxy_permissions... OK
  Applying auth.0012_alter_user_first_name_max_length... OK
  Applying sessions.0001_initial... OK
  Applying user.0001_initial... OK
  Applying user.0002_departement... OK
```
>这样就在根目录为我们生成了db.sqlite3  
![img_5.png](img_5.png)  
这样就生成好了,由于该项目没做瘦身,所以只需要关注创建好的user以及articles表  
> ![img_6.png](img_6.png)    


名称的规则一般是app名_表名    


### 常见注意事项  
和我们学flask的时候一样,创建好表之后不要手动修改数据库表的结构  
因为我们的orm创建好的表进行修改之后直接对表操作的话orm会与数据库不一致  
如果想修改表结构那就先注释掉要进行修改的字段,然后python manage.py makemigrations,然后在此基础上修改之后进行python manage.py migrate

演示:删除department表  
去注释掉它  
```python
from django.db import models

# Create your models here.



class User(models.Model):

    name = models.CharField(max_length=16)
    age = models.IntegerField()


#
# class Departement(models.Model):
#     departement = models.CharField(max_length=32)
```

然后`python manage.py makemigrations`    
可以看到下面orm已经给我们正确的反馈了,
```text
(ISV) D:\haohaicheng\Djangolearn\10ORM>python manage.py makemigrations
Migrations for 'user':
  apps\user\migrations\0003_delete_departement.py
    - Delete model Departement
```  
接下来执行`python manage.py migrate` 
```text
(ISV) D:\haohaicheng\Djangolearn\10ORM>python manage.py migrate
Operations to perform:
  Apply all migrations: admin, articles, auth, contenttypes, sessions, user
Running migrations:
  Applying user.0003_delete_departement... OK

```

然后可以看到右侧的数据库控制台就没有department表了  
![img_7.png](img_7.png)  



### orm常见字段  
我们可以顺着settings.py中的路径  
```python
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': BASE_DIR / 'db.sqlite3',
    }
}
```  

去site-packages中django/db/backends/sqlite3/base.py中查看源码   
```python
class DatabaseWrapper(BaseDatabaseWrapper):
    vendor = 'sqlite'
    display_name = 'SQLite'
    # SQLite doesn't actually support most of these types, but it "does the right
    # thing" given more verbose field definitions, so leave them as is so that
    # schema inspection is more useful.
    data_types = {
        'AutoField': 'integer',
        'BigAutoField': 'integer',
        'BinaryField': 'BLOB',
        'BooleanField': 'bool', 
        'CharField': 'varchar(%(max_length)s)',
        'DateField': 'date',
        'DateTimeField': 'datetime',
        'DecimalField': 'decimal', #存储精确的小数用的,对于需要存储精确小数(如转账,模型权重)需要这个
        'DurationField': 'bigint',
        'FileField': 'varchar(%(max_length)s)',
        'FilePathField': 'varchar(%(max_length)s)',
        'FloatField': 'real',
        'IntegerField': 'integer',
        'BigIntegerField': 'bigint',
        'IPAddressField': 'char(15)',
        'GenericIPAddressField': 'char(39)',
        'JSONField': 'text',
        'NullBooleanField': 'bool',
        'OneToOneField': 'integer',
        #positive家族提供无符号整数,一般都是存储无符号正数信息,如商品价格,没有负数这么一说
        'PositiveBigIntegerField': 'bigint unsigned',  
        'PositiveIntegerField': 'integer unsigned',
        'PositiveSmallIntegerField': 'smallint unsigned',
        'SlugField': 'varchar(%(max_length)s)',
        'SmallAutoField': 'integer',
        'SmallIntegerField': 'smallint',
        'TextField': 'text',
        'TimeField': 'time',
        'UUIDField': 'char(32)',
    }
```

### 创建orm映射时我们还可以指定verbose_name来为字段起名字,和当时mysql那种是一样的效果  

```python

class User(models.Model):

    name = models.CharField(verbose_name='姓名',max_length=16)
    age = models.IntegerField()
    pdate = models.DateField(verbose_name='注册日期',default=date.today)
    pdate_time = models.DateField(verbose_name='注册日期及时间',default=datetime.now)
    #还可以这样
    pdate = model.DateField(auto_now=True) #这样不用传入默认就是当前的时间


```



### orm常见参数   
CharField常用的:
- default
- max_length
- null
- blank (通常和null=True结合使用)
- db_index 就像之前mysql那时学的索引一样,它可以提升查询效率
- unique 唯一约束
- choices 限定离散选择,设置存入表中的内容只能是指定的元组中的内容

IntegerField、BigIntegerField、SmallIntegerField常用的:   
和上面几乎都是一样的,但是不用写max_length  
还有就是它用choices，譬如二元性别选取的时候就得这么写models.SmallIntegerField(choices((1,'男'),(0,'女')))

```python
name = models.CharField(verbose_name='姓名', max_length=16)
code = models.CharField(choices(("sh", "上海"), ("bj", "北京")))
# 这样之后存入的只能是'sh'和'bj'如果以后从表中取数据取到'sh'了就转换成'上海'
age = models.IntegerField(null=True, blank=True, db_index=True)  # 指定其可以为空
rent = models.BigIntegerField(verbose_name='')
salary = models.SmallIntegerField(verbose_name='')
gender = models.SmallIntegerField(choices((1, '男'), (0, '女')), default=1)
salary = models.DecimalField(verbose_name='工资', max_digits=10, decimal_places=2)  # 总共十位数,有两位来保存小数,八位保存整数

```

值得注意的是如果DecimalField不加默认值的话是会报错的,而且加默认值为0的话一定要看看自己的decimal_placces设置的是几位小数!!!!!!!

>(ISV) D:\haohaicheng\Djangolearn\10ORM>python manage.py makemigrations
You are trying to add a non-nullable field 'salary' to user without a default; we can't do that (the database needs something to populate existing rows).
Please select a fix:
 1) Provide a one-off default now (will be set on all existing rows with a null value for this column)
 2) Quit, and let me add a default in models.py
Select an option: 2


修正如下  
```python
    salary = models.DecimalField(verbose_name='工资',max_digits=10,decimal_places=2,default=0.00) #总共十位数,有两位来保存小数,八位保存整数
```
这样就不会报错了



## 多表操作   
之前学习flaskorm的时候也学过表的关系,如主键外键对应,如1对多关系,多对多关系   
回看之前的flask
```python
class Article(db.Model):
    __tablename__ = 'article'
    id = db.Column(db.Integer, primary_key=True, autoincrement=True)
    title = db.Column(db.String(30), nullable=False)
    content = db.Column(db.Text, nullable=False)
    pdatetime = db.Column(db.DateTime, default=datetime.now)
    click_num = db.Column(db.Integer, default=0)
    save_num = db.Column(db.Integer, default=0)
    love_num = db.Column(db.Integer, default=0)
    user_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False)  # 添加外键实现一对多
    type_id = db.Column(db.Integer,db.ForeignKey('article_type.id'),nullable=True)
    comment = db.relationship('Comment', backref='article')

    def __str__(self):
        return self.title


class Comment(db.Model):
    __tablename__ = 'comment'
    id = db.Column(db.Integer, primary_key=True, autoincrement=True)
    comment = db.Column(db.String(255), nullable=False)
    # tips:与用户表的主键拉手
    uid = db.Column(db.Integer, db.ForeignKey('user.id'))
    # tips:设置外键,与文章表的主键拉手
    aid = db.Column(db.Integer, db.ForeignKey('article.id'))
    cdatetime = db.Column(db.DateTime, default=datetime.now)

    def __str__(self):
        return self.comment
```
### 1. 一对多操作
Django的话是这样设置一对一关系的   

如一个部门有多个用户,那就要给用户设置外键
```python
class User(models.Model):
    name = models.CharField(verbose_name='姓名', max_length=16, db_index=True)
    age = models.IntegerField()
    pdate = models.DateField(verbose_name='注册日期', default=date.today)
    pdate_time = models.DateField(verbose_name='注册日期及时间', default=datetime.now)
    registe_date = models.DateField(verbose_name='注册时间', auto_now=True)
    salary = models.DecimalField(verbose_name='工资', max_digits=10, decimal_places=2,
                                 default=0.00)  # 总共十位数,有两位来保存小数,八位保存整数
    email = models.CharField(verbose_name='邮箱', unique=True, max_length=128, null=True,
                             blank=True)  # 一般开发中会指定邮箱为唯一邮箱,而用户名可以不唯一

    #新建一个字段显示用户的部门id,to表示关联的是哪张表!!!,to_field表示当前字段跟to的表的哪个字段关联
    did = models.ForeignKey(verbose_name="部门id",to='Department',to_field='id',on_delete=models.CASCADE)#important:其实to_field不写的话默认就会用to的表的id来作为外键,但是如果要用其它字段来连表的话就需要自己指定了


#
class Departement(models.Model):
    """部门表"""
    #由于django会默认帮我们生成id主键自增,所以我们不用自己设置,它会自动帮我们生成
    departement = models.CharField(verbose_name='部门',max_length=32)

```

> 为什么要设置on_delete=models.CASCADE呢？
> 因为我们让部门表的主键作为user表的外键了,因为外键约束的原因,如果我们单独操作user表进行用户删除还是可以的  
> 但是如果我们对部门表的某个部门进行删除,user表就会因为设置了外键约束但是外键消失掉而产生崩溃  
> 所以我们才设置级联删除,也就是如果部门表进行部门删除的时候,用户表中所属该部门的用户数据也会被删除掉  
> 
> 

### 2 多对多关系 
我们之前学的flask中是这样实现多对多关系的    
譬如一个用户可以购买多种商品,一种商品也可以被多个用户购买  
flask中的解决方式是创建一个关系表来存储两个要进行多对多关系对照的主表    
然后在其中一张主表中指定secondary来指明两个主表的关系实现是那个关系表来完成的  
```python
# @Author    : 百年
# @FileName  :models.py
# @DateTime  :2025/8/28 17:32

from exts.extensions import db

class Goods(db.Model):
    id = db.Column(db.Integer,primary_key=True,autoincrement=True)
    gname = db.Column(db.String(100),nullable=False)
    price = db.Column(db.Float,nullable=False)
    users = db.relationship('User',backref='goods_lst',secondary='user_goods')
    #important:多对多的话就需要写上secondary并跟上关系表,本案例中就是跟上了user_goods这张有了俩外键约束的表
    def __str__(self):
        return self.gname



#start_cb: 创建user与goods的关系表
class User_goods(db.Model):
    id = db.Column(db.Integer,primary_key=True,autoincrement=True)
    user_id = db.Column(db.Integer,db.ForeignKey('user.id'))
    goods_id = db.Column(db.Integer,db.ForeignKey('goods.id'))
    number = db.Column(db.Integer,default=1)
    #或者直接写这里也是可以的,但是这样的话得写俩,但是这样看着确实和Django的就很像了,无非就是多写俩关系而已!!
    # 定义从关系表到主表的关系
    user = db.relationship('User', backref='user_goods_items') # backref命名为 user_goods_items
    goods = db.relationship('Goods', backref='user_goods_items') # backref命名为 user_goods_items


class User(db.Model):
    __tablename__ = 'user'
    id = db.Column(db.Integer, primary_key=True, autoincrement=True)
    username = db.Column(db.String(20), nullable=False)
    password = db.Column(db.String(128), nullable=False)  # 要放的是要加密的密码,所以大小应当是加密之后的大小,故db.String(Size) 的Size要谨慎设置
    phone = db.Column(db.String(11), unique=True, nullable=False)
    email = db.Column(db.String(30))
    icon = db.Column(db.String(100))
    regi_date = db.Column(db.DateTime, default=datetime.now)
    isdelete = db.Column(db.Boolean, default=False)  # 逻辑删除
    # start_cb:增减一个字段,不会在数据库中出现,用于链接字段,relationship是在view和templates中体现的
    articles = db.relationship('Article', backref='user', lazy='select')
    photo = db.relationship('Photo', backref='user')
    comment=db.relationship('Comment',backref='user')
    selfintro = db.Relationship('Aboutme',backref='user')
    # end_cb 需要注意它是模板层面的,所以不需要再做迁移操作
    def __str__(self):
        return self.username
```

#### 来看看Django怎么写   
其实Django也是引入关系表    
建立第三张表来表示   

```python

from django.db import models

class User(models.Model):
    uid = models.CharField(max_length=12,verbose_name='用户id')
    name = models.CharField(verbose_name="用户名")

class goods(models.Model):
    gname = models.CharField(verbose_name="商品名")
    price = models.DecimalField(verbose_name='价格',decimal_places=2)

class goods_user(models.Model):
    uid = models.ForeignKey(to='User',to_field='uid',on_delete=models.CASCADE)
    gid = models.ForeignKey(to='goods',to_field='id',on_delete=models.CASCADE)
```


django还有另一种写法,写了之后可以让django自动生成    
在俩要进行多对多关联的主表中的任何一个里面设置relation  
这里以User中设置为例,也可以照着同样的只设置在goods里
```python
from django.db import models
class User(models.Model):
    uid = models.CharField(max_length=12,verbose_name='用户id')
    name = models.CharField(verbose_name="用户名")
    relation = models.ManyToManyField(verbose_name="用户商品表",to="goods")
class goods(models.Model):
    gname = models.CharField(verbose_name="商品名")
    price = models.DecimalField(verbose_name='价格',decimal_places=2)
    #或者只在goods里写 
    #relation = models.ManyToManyField(to="User")

```

但是一般不用这个写,我们还是常用上面的引入第三张表比较好  


## 补充
如果没有做项目瘦身的话那user可能会被认为是Django中自带的user  
为了解决这个问题,我们可以使用`懒引用`  

譬如User表在user这个app之中,那我们就使用懒引用来将其引用住

```python
class Goods(models.Model):
    goods_name = models.CharField(verbose_name='商品名称',max_length=16)
    goods_price = models.DecimalField(max_digits=10,decimal_places=2,default=0.0)


#tips:创建goods_user表来进行多对多表构建
class Goods_User(models.Model):
    #用懒引用,它机会自动从我们注册的app中找
    user_id = models.ForeignKey(to="user.User",to_field="id",on_delete=models.CASCADE)
    goods_id = models.ForeignKey(to="Goods",to_field="id",on_delete=models.CA
```